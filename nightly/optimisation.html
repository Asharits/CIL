

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Optimisation framework &mdash; CIL v21.2.0-2-g54ef49b documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Developer’s guide" href="developer_guide.html" />
    <link rel="prev" title="Read/ write AcquisitionData and ImageData" href="io.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> CIL
          

          
          </a>

          
            
            
              <div class="version">
                v21.2.0-2-g54ef49b
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="framework.html">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Read/ write AcquisitionData and ImageData</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimisation framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#algorithm">Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operator">Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-base-classes">Operator base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trivial-operators">Trivial operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradientoperator">GradientOperator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function">Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-classes">Base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-functions">Simple functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-operator-and-a-function">Composition of operator and a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indicator-box">Indicator box</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kullbackleibler">KullbackLeibler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l1-norm">L1 Norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#squared-l2-norm-squared">Squared L2 norm squared</a></li>
<li class="toctree-l3"><a class="reference internal" href="#least-squares">Least Squares</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l21-norm">Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smooth-mixed-l21-norm">Smooth Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#total-variation">Total variation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#block-framework">Block Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#blockdatacontainer">BlockDataContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-function">Block Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-operator">Block Operator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developer’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="processors.html">Processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CIL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Optimisation framework</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/optimisation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="optimisation-framework">
<h1>Optimisation framework<a class="headerlink" href="#optimisation-framework" title="Permalink to this headline">¶</a></h1>
<p>This package allows rapid prototyping of optimisation-based reconstruction problems, i.e. defining and solving different optimization problems to enforce different properties on the reconstructed image.</p>
<p>Firstly, it provides an object-oriented framework for defining mathematical operators and functions as well a collection of useful example operators and functions. Both smooth and non-smooth functions can be used.</p>
<p>Further, it provides a number of high-level generic implementations of optimisation algorithms to solve genericlly formulated optimisation problems constructed from operator and function objects.</p>
<p>The fundamental components are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code>: A class specifying a (currently linear) operator</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code>: A class specifying mathematical functions such as a least squares data fidelity.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code>: Implementation of an iterative optimisation algorithm to solve a particular generic optimisation problem. Algorithms are iterable Python object which can be run in a for loop. Can be stopped and warm restarted.</p></li>
</ul>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<p>A number of generic algorithm implementations are provided including
Gradient Descent (GD), Conjugate Gradient Least Squares (CGLS),
Simultaneous Iterative Reconstruction Technique (SIRT), Primal Dual Hybrid
Gradient (PDHG) and Fast Iterative Shrinkage Thresholding Algorithm (FISTA).</p>
<p>An algorithm is designed for a
particular generic optimisation problem accepts and number of
:code:<a href="#id1"><span class="problematic" id="id2">`</span></a>Function`s and/or :code:<a href="#id3"><span class="problematic" id="id4">`</span></a>Operator`s as input to define a specific instance of
the generic optimisation problem to be solved.
They are iterable objects which can be run in a for loop.
The user can provide a stopping criterion different than the default max_iteration.</p>
<p>New algorithms can be easily created by extending the <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> class.
The user is required to implement only 4 methods: set_up, __init__, update and update_objective.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">set_up</span></code> and <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> are used to configure the algorithm</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update</span></code> is the actual iteration updating the solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> defines how the objective is calculated.</p></li>
</ul>
<p>For example, the implementation of the update of the Gradient Descent
algorithm to minimise a Function will only be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> provides the infrastructure to continue iteration, to access the values of the
objective function in subsequent iterations, the time for each iteration, and to provide a nice
print to screen of the status of the optimisation.</p>
<dl class="class">
<dt id="cil.optimisation.algorithms.Algorithm">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">Algorithm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for iterative algorithms</p>
<p>provides the minimal infrastructure.</p>
<p>Algorithms are iterables so can be easily run in a for loop. They will
stop as soon as the stop cryterion is met.
The user is required to implement the <code class="code docutils literal notranslate"><span class="pre">set_up</span></code>, <code class="code docutils literal notranslate"><span class="pre">__init__</span></code>, <code class="code docutils literal notranslate"><span class="pre">update</span></code> and
and <code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> methods</p>
<p>A courtesy method <code class="code docutils literal notranslate"><span class="pre">run</span></code> is available to run <code class="code docutils literal notranslate"><span class="pre">n</span></code> iterations. The method accepts
a <code class="code docutils literal notranslate"><span class="pre">callback</span></code> function that receives the current iteration number and the actual objective
value and can be used to trigger print to screens and other user interactions. The <code class="code docutils literal notranslate"><span class="pre">run</span></code>
method will stop when the stopping cryterion is met.</p>
<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm._Algorithm__set_up_logger">
<code class="sig-name descname">_Algorithm__set_up_logger</code><span class="sig-paren">(</span><em class="sig-param">fname</em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm._Algorithm__set_up_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the logger if desired</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 0</em>) – maximum number of iterations</p></li>
<li><p><strong>update_objectice_interval</strong> – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p></li>
<li><p><strong>log_file</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – log verbose output to file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.__next__">
<code class="sig-name descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__next__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__next__" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>calling this method triggers update and update_objective</p>
</dd></dl>

<dl class="attribute">
<dt id="cil.optimisation.algorithms.Algorithm.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.get_last_loss">
<code class="sig-name descname">get_last_loss</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_last_loss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.get_last_objective">
<code class="sig-name descname">get_last_objective</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_last_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.get_output">
<code class="sig-name descname">get_output</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution found</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.iterations">
<em class="property">property </em><code class="sig-name descname">iterations</code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.iterations" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.loss">
<em class="property">property </em><code class="sig-name descname">loss</code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.loss" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when 
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.max_iteration">
<em class="property">property </em><code class="sig-name descname">max_iteration</code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.max_iteration_stop_cryterion">
<code class="sig-name descname">max_iteration_stop_cryterion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.max_iteration_stop_cryterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration_stop_cryterion" title="Permalink to this definition">¶</a></dt>
<dd><p>default stop cryterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.objective">
<em class="property">property </em><code class="sig-name descname">objective</code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iterations=None</em>, <em class="sig-param">verbose=1</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.run" title="Permalink to this definition">¶</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number, 
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to 
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
<li><p><strong>very_verbose</strong> – deprecated bool, useful for algorithms with primal and dual objectives (PDHG), 
prints to screen both primal and dual</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.should_stop">
<code class="sig-name descname">should_stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.should_stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>default stopping cryterion: number of iterations</p>
<p>The user can change this in concrete implementatition of iterative algorithms.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.update_previous_solution">
<code class="sig-name descname">update_previous_solution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update_previous_solution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_previous_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the previous solution with the current one</p>
<p>The concrete algorithm calls update_previous_solution. Normally this would 
entail the swapping of pointers:</p>
<p>tmp = self.x_old
self.x_old = self.x
self.x = tmp</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.Algorithm.verbose_output">
<code class="sig-name descname">verbose_output</code><span class="sig-paren">(</span><em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.verbose_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.verbose_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.GD">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">GD</code><span class="sig-paren">(</span><em class="sig-param">initial=None</em>, <em class="sig-param">objective_function=None</em>, <em class="sig-param">step_size=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient Descent algorithm</p>
<dl class="method">
<dt id="cil.optimisation.algorithms.GD.armijo_rule">
<code class="sig-name descname">armijo_rule</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.armijo_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.armijo_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the Armijo rule to calculate the step size (step_size)</p>
<p><a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080">https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080</a></p>
<p>The Armijo rule runs a while loop to find the appropriate step_size by starting
from a very large number (alpha). The step_size is found by dividing alpha by 2 
in an iterative way until a certain criterion is met. To avoid infinite loops, we 
add a maximum number of times the while loop is run.</p>
<p>This rule would allow to reach a minimum step_size of 10^-alpha.</p>
<p>if
alpha = numpy.power(10,gamma)
delta = 3
step_size = numpy.power(10, -delta)
with armijo rule we can get to step_size from initial alpha by repeating the while loop k times 
where 
alpha / 2^k = step_size
10^gamma / 2^k = 10^-delta 
2^k = 10^(gamma+delta)
k = gamma+delta / log10(2) approx 3.3 * (gamma+delta)</p>
<p>if we would take by default delta = gamma
kmax = numpy.ceil ( 2 * gamma / numpy.log10(2) )
kmax = numpy.ceil (2 * numpy.log10(alpha) / numpy.log10(2))</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.GD.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">initial</em>, <em class="sig-param">objective_function</em>, <em class="sig-param">step_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – initial guess</p></li>
<li><p><strong>objective_function</strong> – objective function to be minimised</p></li>
<li><p><strong>step_size</strong> – step size</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.GD.should_stop">
<code class="sig-name descname">should_stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.should_stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>default stopping cryterion: number of iterations</p>
<p>The user can change this in concrete implementatition of iterative algorithms.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.GD.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Single iteration</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.GD.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.CGLS">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">CGLS</code><span class="sig-paren">(</span><em class="sig-param">initial=None</em>, <em class="sig-param">operator=None</em>, <em class="sig-param">data=None</em>, <em class="sig-param">tolerance=1e-06</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate Gradient Least Squares algorithm</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min || A x - b ||^2_2\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Parameters :</p>
<blockquote>
<div><p>:parameter operator : Linear operator for the inverse problem
:parameter initial : Initial guess ( Default initial = 0)
:parameter data : Acquired data to reconstruct       
:parameter tolerance: Tolerance/ Stopping Criterion to end CGLS algorithm</p>
</div></blockquote>
<dl class="simple">
<dt>Reference:</dt><dd><p><a class="reference external" href="https://web.stanford.edu/group/SOL/software/cgls/">https://web.stanford.edu/group/SOL/software/cgls/</a></p>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.algorithms.CGLS.flag">
<code class="sig-name descname">flag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.flag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.flag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns whether the tolerance has been reached</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.CGLS.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">initial</em>, <em class="sig-param">operator</em>, <em class="sig-param">data</em>, <em class="sig-param">tolerance=1e-06</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – Linear operator for the inverse problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>data</strong> – Acquired data to reconstruct</p></li>
<li><p><strong>tolerance</strong> – Tolerance/ Stopping Criterion to end CGLS algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.CGLS.should_stop">
<code class="sig-name descname">should_stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.should_stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stopping criterion</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.CGLS.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update" title="Permalink to this definition">¶</a></dt>
<dd><p>single iteration</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.CGLS.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.SIRT">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">SIRT</code><span class="sig-paren">(</span><em class="sig-param">initial=None</em>, <em class="sig-param">operator=None</em>, <em class="sig-param">data=None</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">constraint=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT" title="Permalink to this definition">¶</a></dt>
<dd><p>Simultaneous Iterative Reconstruction Technique</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[A x = b\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – Initial guess</p></li>
<li><p><strong>operator</strong> – Linear operator for the inverse problem</p></li>
<li><p><strong>data</strong> – Acquired data to reconstruct</p></li>
<li><p><strong>constraint</strong> – <p>Function proximal method
e.g.  <span class="math notranslate nohighlight">\(x\in[0, 1]\)</span>, <code class="code docutils literal notranslate"><span class="pre">IndicatorBox</span></code> to enforce box constraints</p>
<blockquote>
<div><p>Default is <code class="code docutils literal notranslate"><span class="pre">None</span></code>).</p>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.algorithms.SIRT.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">initial</em>, <em class="sig-param">operator</em>, <em class="sig-param">data</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">constraint=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – Initial guess</p></li>
<li><p><strong>operator</strong> – Linear operator for the inverse problem</p></li>
<li><p><strong>data</strong> – Acquired data to reconstruct</p></li>
<li><p><strong>lower</strong> – Scalar specifying lower bound constraint on pixel values, default -inf</p></li>
<li><p><strong>upper</strong> – Scalar specifying upper bound constraint on pixel values, default +inf</p></li>
<li><p><strong>constraint</strong> – <p>More general constraint, given as Function proximal method
e.g.  <span class="math notranslate nohighlight">\(x\in[0, 1]\)</span>, <code class="code docutils literal notranslate"><span class="pre">IndicatorBox</span></code> to enforce box constraints</p>
<blockquote>
<div><p>Default is <code class="code docutils literal notranslate"><span class="pre">None</span></code>). constraint takes priority over lower and upper.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.SIRT.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.SIRT.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.FISTA">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">FISTA</code><span class="sig-paren">(</span><em class="sig-param">initial=None</em>, <em class="sig-param">f=None</em>, <em class="sig-param">g=&lt;cil.optimisation.functions.Function.ZeroFunction object&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast Iterative Shrinkage-Thresholding Algorithm</p>
<p>Problem :</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Parameters :</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param initial</dt>
<dd class="field-odd"><p>Initial guess ( Default initial = 0)</p>
</dd>
<dt class="field-even">param f</dt>
<dd class="field-even"><p>Differentiable function</p>
</dd>
<dt class="field-odd">param g</dt>
<dd class="field-odd"><p>Convex function with ” simple ” proximal operator</p>
</dd>
</dl>
</div></blockquote>
<p>Reference:</p>
<blockquote>
<div><p>Beck, A. and Teboulle, M., 2009. A fast iterative shrinkage-thresholding 
algorithm for linear inverse problems. 
SIAM journal on imaging sciences,2(1), pp.183-202.</p>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.algorithms.FISTA.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">initial=None</em>, <em class="sig-param">f=None</em>, <em class="sig-param">g=&lt;cil.optimisation.functions.Function.ZeroFunction object&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>FISTA algorithm creator</p>
<p>initialisation can be done at creation time if all 
proper variables are passed or later with set_up</p>
<p>Optional parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>f</strong> – Differentiable function</p></li>
<li><p><strong>g</strong> – Convex function with ” simple ” proximal operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.FISTA.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">initial</em>, <em class="sig-param">f</em>, <em class="sig-param">g=&lt;cil.optimisation.functions.Function.ZeroFunction object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>f</strong> – Differentiable function</p></li>
<li><p><strong>g</strong> – Convex function with ” simple ” proximal operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.FISTA.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.FISTA.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.PDHG">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">PDHG</code><span class="sig-paren">(</span><em class="sig-param">f=None</em>, <em class="sig-param">g=None</em>, <em class="sig-param">operator=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">sigma=1.0</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">use_axpby=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG" title="Permalink to this definition">¶</a></dt>
<dd><p>Primal Dual Hybrid Gradient</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(Kx) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – Linear Operator = K</p></li>
<li><p><strong>f</strong> – Convex function with “simple” proximal of its conjugate.</p></li>
<li><p><strong>g</strong> – Convex function with “simple” proximal</p></li>
<li><p><strong>tau</strong> – Step size parameter for Primal problem</p></li>
<li><p><strong>sigma</strong> – Step size parameter for Dual problem</p></li>
</ul>
</dd>
</dl>
<p>Remark: Convergence is guaranted provided that</p>
<div class="math notranslate nohighlight">
\[\tau \sigma \|K\|^{2} &lt;1\]</div>
<p>Reference:</p>
<blockquote>
<div><p>(a) A. Chambolle and T. Pock (2011), “A first-order primal–dual algorithm for convex
problems with applications to imaging”, J. Math. Imaging Vision 40, 120–145.</p>
<p>(b) E. Esser, X. Zhang and T. F. Chan (2010), “A general framework for a class of first
order primal–dual algorithms for convex optimization in imaging science”,
SIAM J. Imaging Sci. 3, 1015–1046.</p>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.algorithms.PDHG.objective">
<em class="property">property </em><code class="sig-name descname">objective</code><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.objective" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.PDHG.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">g</em>, <em class="sig-param">operator</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">sigma=1.0</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – a Linear Operator</p></li>
<li><p><strong>f</strong> – Convex function with “simple” proximal of its conjugate.</p></li>
<li><p><strong>g</strong> – Convex function with “simple” proximal</p></li>
<li><p><strong>tau</strong> – Step size parameter for Primal problem</p></li>
<li><p><strong>sigma</strong> – Step size parameter for Dual problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.PDHG.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.PDHG.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.PDHG.update_previous_solution">
<code class="sig-name descname">update_previous_solution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update_previous_solution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_previous_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the previous solution with the current one</p>
<p>The concrete algorithm calls update_previous_solution. Normally this would 
entail the swapping of pointers:</p>
<p>tmp = self.x_old
self.x_old = self.x
self.x = tmp</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.LADMM">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">LADMM</code><span class="sig-paren">(</span><em class="sig-param">f=None</em>, <em class="sig-param">g=None</em>, <em class="sig-param">operator=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">sigma=1.0</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM" title="Permalink to this definition">¶</a></dt>
<dd><p>LADMM is the Linearized Alternating Direction Method of Multipliers (LADMM)</p>
<p>General form of ADMM : min_{x} f(x) + g(y), subject to Ax + By = b</p>
<p>Case: A = Id, B = -K, b = 0   ==&gt; min_x f(Kx) + g(x)</p>
<p>The quadratic term in the augmented Lagrangian is linearized for the x-update.</p>
<p>Main algorithmic difference is that in ADMM we compute two proximal subproblems, 
where in the PDHG a proximal and proximal conjugate.</p>
<p>Reference (Section 8) : <a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf">https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf</a></p>
<blockquote>
<div><p>x^{k} = prox_{      au f } (x^{k-1} - tau/sigma A^{T}(Ax^{k-1} - z^{k-1} + u^{k-1} )</p>
<p>z^{k} = prox_{sigma g} (Ax^{k} + u^{k-1})</p>
<p>u^{k} = u^{k-1} + Ax^{k} - z^{k}</p>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.algorithms.LADMM.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">g</em>, <em class="sig-param">operator</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">sigma=1.0</em>, <em class="sig-param">initial=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.LADMM.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.LADMM.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.algorithms.SPDHG">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.algorithms.</code><code class="sig-name descname">SPDHG</code><span class="sig-paren">(</span><em class="sig-param">f=None</em>, <em class="sig-param">g=None</em>, <em class="sig-param">operator=None</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">prob=None</em>, <em class="sig-param">gamma=1.0</em>, <em class="sig-param">use_axpby=True</em>, <em class="sig-param">norms=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG" title="Permalink to this definition">¶</a></dt>
<dd><p>Stochastic Primal Dual Hybrid Gradient</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(Kx) + g(x) = \min_{x} \sum f_i(K_i x) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – BlockOperator of Linear Operators</p></li>
<li><p><strong>f</strong> – BlockFunction, each function with “simple” proximal of its conjugate</p></li>
<li><p><strong>g</strong> – Convex function with “simple” proximal</p></li>
<li><p><strong>sigma=</strong><strong>(</strong><strong>sigma_i</strong><strong>)</strong> – List of Step size parameters for Dual problem</p></li>
<li><p><strong>tau</strong> – Step size parameter for Primal problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>prob</strong> – List of probabilities</p></li>
</ul>
</dd>
</dl>
<p>Remark: Convergence is guaranted provided that [2, eq. (12)]:</p>
<div class="math notranslate nohighlight">
\[\|\sigma[i]^{1/2} * K[i] * tau^{1/2} \|^2  &lt; p_i for all i\]</div>
<dl class="simple">
<dt>Remark: Notation for primal and dual step-sizes are reversed with comparison</dt><dd><p>to PDGH.py</p>
</dd>
<dt>Remark: this code implements serial sampling only, as presented in [2]</dt><dd><p>(to be extended to more general case of [1] as future work)</p>
</dd>
</dl>
<p>References:</p>
<blockquote>
<div><p>[1]”Stochastic primal-dual hybrid gradient algorithm with arbitrary 
sampling and imaging applications”,
Chambolle, Antonin, Matthias J. Ehrhardt, Peter Richtárik, and Carola-Bibiane Schonlieb,
SIAM Journal on Optimization 28, no. 4 (2018): 2783-2808.</p>
<p>[2]”Faster PET reconstruction with non-smooth priors by randomization and preconditioning”,
Matthias J Ehrhardt, Pawel Markiewicz and Carola-Bibiane Schönlieb,
Physics in Medicine &amp; Biology, Volume 64, Number 22, 2019.</p>
</div></blockquote>
<p>Example of usage: See <a class="reference external" href="https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py">https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py</a></p>
<dl class="method">
<dt id="cil.optimisation.algorithms.SPDHG.objective">
<em class="property">property </em><code class="sig-name descname">objective</code><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.SPDHG.set_up">
<code class="sig-name descname">set_up</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">g</em>, <em class="sig-param">operator</em>, <em class="sig-param">tau=None</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">initial=None</em>, <em class="sig-param">prob=None</em>, <em class="sig-param">gamma=1.0</em>, <em class="sig-param">norms=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – BlockOperator of Linear Operators</p></li>
<li><p><strong>f</strong> – BlockFunction, each function with “simple” proximal of its conjugate.</p></li>
<li><p><strong>g</strong> – Convex function with “simple” proximal</p></li>
<li><p><strong>sigma</strong> – list of Step size parameters for dual problem</p></li>
<li><p><strong>tau</strong> – Step size parameter for primal problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>prob</strong> – List of probabilities</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.SPDHG.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.algorithms.SPDHG.update_objective">
<code class="sig-name descname">update_objective</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.update_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="operator">
<h2>Operator<a class="headerlink" href="#operator" title="Permalink to this headline">¶</a></h2>
<p>The two most important methods are <code class="code docutils literal notranslate"><span class="pre">direct</span></code> and <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code>
methods that describe the result of applying the operator, and its
adjoint respectively, onto a compatible <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> input.
The output is another <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> object or subclass
hereof. An important special case is to represent the tomographic
forward and backprojection operations.</p>
<div class="section" id="operator-base-classes">
<h3>Operator base classes<a class="headerlink" href="#operator-base-classes" title="Permalink to this headline">¶</a></h3>
<p>All operators extend the <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> class. A special class is the <code class="code docutils literal notranslate"><span class="pre">LinearOperator</span></code>
which represents an operator for which the <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code> operation is defined.
A <code class="code docutils literal notranslate"><span class="pre">ScaledOperator</span></code> represents the multiplication of any operator with a scalar.</p>
<dl class="class">
<dt id="cil.optimisation.operators.Operator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">Operator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Operator that maps from a space X -&gt; Y</p>
<dl class="method">
<dt id="cil.optimisation.operators.Operator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.__neg__">
<code class="sig-name descname">__neg__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__neg__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return -self</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.__rmul__">
<code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the multiplication by a scalar on the left</p>
<p>returns a ScaledOperator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.__sub__">
<code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subtraction of the operators.</p>
</dd></dl>

<dl class="attribute">
<dt id="cil.optimisation.operators.Operator.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#cil.optimisation.operators.Operator.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the norm of the Operator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.domain_geometry">
<code class="sig-name descname">domain_geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.domain_geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.domain_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the Operator: X space</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.is_linear">
<code class="sig-name descname">is_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.is_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.is_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the norm of the Operator</p>
<p>Calling norm triggers the calculation of the norm of the operator. Normally this
is a computationally expensive task, therefore we store the result of norm into 
a member of the class. If the calculation has already run, following calls to 
norm just return the saved member. 
It is possible to force recalculation by setting the optional force parameter. Notice that
norm doesn’t take notice of how many iterations or of the initialisation of the PowerMethod, 
so in case you want to recalculate by setting a higher number of iterations or changing the
starting point or both you need to set <code class="code docutils literal notranslate"><span class="pre">force=True</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default = 25</em>) – number of iterations to run</p></li>
<li><p><strong>x_init</strong> (same type as domain, a subclass of <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional, default None) – starting point for the iteration in the operator domain</p></li>
<li><p><strong>force</strong> (boolean, default <code class="code docutils literal notranslate"><span class="pre">False</span></code>) – forces the recalculation of the norm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.Operator.range_geometry">
<code class="sig-name descname">range_geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.range_geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.range_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the range of the Operator: Y space</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.LinearOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">LinearOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>A Linear Operator that maps from a space X &lt;-&gt; Y</p>
<dl class="method">
<dt id="cil.optimisation.operators.LinearOperator.PowerMethod">
<em class="property">static </em><code class="sig-name descname">PowerMethod</code><span class="sig-paren">(</span><em class="sig-param">operator</em>, <em class="sig-param">iterations</em>, <em class="sig-param">x_init=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.PowerMethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.PowerMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Power method to calculate iteratively the Lipschitz constant</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<code class="code docutils literal notranslate"><span class="pre">LinearOperator</span></code>) – input operator</p></li>
<li><p><strong>iterations</strong> – number of iterations to run</p></li>
<li><p><strong>x_init</strong> – starting point for the iteration in the operator domain</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tuple with: L, list of L at each iteration, the data the iteration worked on.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.LinearOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.LinearOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.LinearOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the norm of the LinearOperator as calculated by the PowerMethod</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default = 25</em>) – number of iterations to run</p></li>
<li><p><strong>x_init</strong> (same type as domain, a subclass of <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional, None) – starting point for the iteration in the operator domain</p></li>
<li><p><strong>force</strong> (boolean, default <code class="code docutils literal notranslate"><span class="pre">False</span></code>) – forces the recalculation of the norm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.LinearOperator.dot_test">
<em class="property">static </em><code class="sig-name descname">dot_test</code><span class="sig-paren">(</span><em class="sig-param">operator</em>, <em class="sig-param">domain_init=None</em>, <em class="sig-param">range_init=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.dot_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.dot_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a dot linearity test on the operator</p>
<p>Evaluates if the following equivalence holds</p>
<div class="math notranslate nohighlight">
\[Ax\times y = y \times A^Tx\]</div>
<p>The equivalence is tested within a user specified precision</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">abs</span><span class="p">(</span><span class="n">desired</span><span class="o">-</span><span class="n">actual</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">decimal</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – operator to test</p></li>
<li><p><strong>range_init</strong> – optional initialisation container in the operator range</p></li>
<li><p><strong>domain_init</strong> – optional initialisation container in the operator domain</p></li>
<li><p><strong>decimal</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 4</em>) – desired precision</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boolean, True if the test is passed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.LinearOperator.is_linear">
<code class="sig-name descname">is_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.is_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.is_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.ScaledOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">ScaledOperator</code><span class="sig-paren">(</span><em class="sig-param">operator</em>, <em class="sig-param">scalar</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to represent the scalar multiplication of an Operator with a scalar.
It holds an operator and a scalar. Basically it returns the multiplication
of the result of direct and adjoint of the operator with the scalar.
For the rest it behaves like the operator it holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – a Operator or LinearOperator</p></li>
<li><p><strong>scalar</strong> – a scalar multiplier</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Example:</dt><dd><p>The scaled operator behaves like the following:</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sop</span> <span class="o">=</span> <span class="n">ScaledOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="cil.optimisation.operators.ScaledOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">operator</em>, <em class="sig-param">scalar</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – a Operator or LinearOperator</p></li>
<li><p><strong>scalar</strong> (<em>float</em>) – a scalar multiplier</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ScaledOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>adjoint method</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ScaledOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>direct method</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ScaledOperator.is_linear">
<code class="sig-name descname">is_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.is_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.is_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>returns whether the operator is linear</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ScaledOperator.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>norm of the operator</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.CompositionOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">CompositionOperator</code><span class="sig-paren">(</span><em class="sig-param">*operators</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="cil.optimisation.operators.CompositionOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*operators</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.CompositionOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the norm of the Operator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.CompositionOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.CompositionOperator.is_linear">
<code class="sig-name descname">is_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.is_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.is_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.DiagonalOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">DiagonalOperator</code><span class="sig-paren">(</span><em class="sig-param">diagonal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>DiagonalOperator:  D: X -&gt; X,  takes in a DataContainer or subclass 
thereof, diag, representing elements on the diagonal of a diagonal 
operator. Maps an element of <span class="math notranslate nohighlight">\(x\in X\)</span> onto the element 
<span class="math notranslate nohighlight">\(y \in X,  y = diag*x\)</span>, where * denotes elementwise multiplication.
In matrix-vector interpretation, if x is a vector of length N, then diag is 
also a vector of length N, and D will be an NxN diagonal matrix with diag 
on its diagonal and zeros everywhere else.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param diagonal</dt>
<dd class="field-odd"><p>DataContainer with diagonal elements</p>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.operators.DiagonalOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">diagonal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.DiagonalOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns D^{*}(y), which is identical to direct, so use direct.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.DiagonalOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates operator norm of DiagonalOperator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.DiagonalOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns D(x)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.ChannelwiseOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">ChannelwiseOperator</code><span class="sig-paren">(</span><em class="sig-param">op</em>, <em class="sig-param">channels</em>, <em class="sig-param">dimension='prepend'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>ChannelwiseOperator:  takes in a single-channel operator op and the 
number of channels to be used, and creates a new multi-channel 
ChannelwiseOperator, which will apply the operator op independently on 
each channel for the number of channels specified.</p>
<p>ChannelwiseOperator supports simple operators as input but not 
BlockOperators. Typically if such behaviour is desired, it can be achieved  
by creating instead a BlockOperator of ChannelwiseOperators.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param op</dt>
<dd class="field-odd"><p>Single-channel operator</p>
</dd>
<dt class="field-even">param channels</dt>
<dd class="field-even"><p>Number of channels</p>
</dd>
<dt class="field-odd">param dimension</dt>
<dd class="field-odd"><p>‘prepend’ (default) or ‘append’ channel dimension onto existing dimensions</p>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">op</em>, <em class="sig-param">channels</em>, <em class="sig-param">dimension='prepend'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns D^{*}(y)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates operator norm of DiagonalOperator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns D(x)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trivial-operators">
<h3>Trivial operators<a class="headerlink" href="#trivial-operators" title="Permalink to this headline">¶</a></h3>
<p>Trivial operators are the following.</p>
<dl class="class">
<dt id="cil.optimisation.operators.IdentityOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">IdentityOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>IdentityOperator:  Id: X -&gt; Y,  Id(x) = xin Y</p>
<p>X : gm_domain
Y : gm_range ( Default: Y = X )</p>
<dl class="method">
<dt id="cil.optimisation.operators.IdentityOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.IdentityOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.IdentityOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates operator norm of IdentityOperator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.IdentityOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.ZeroOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">ZeroOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>ZeroOperator:  O: X -&gt; Y,  maps any element of <span class="math notranslate nohighlight">\(x\in X\)</span> into the zero element <span class="math notranslate nohighlight">\(\in Y,  O(x) = O_{Y}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gm_domain</strong> – domain of the operator</p></li>
<li><p><strong>gm_range</strong> – range of the operator, default: same as domain</p></li>
</ul>
</dd>
</dl>
<p>Note:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}O^{*}: Y^{*} -&gt; X^{*} \text{(Adjoint)}\\&lt; O(x), y &gt; = &lt; x, O^{*}(y) &gt;\end{aligned}\end{align} \]</div>
<dl class="method">
<dt id="cil.optimisation.operators.ZeroOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ZeroOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns O^{*}(y)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ZeroOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates operator norm of ZeroOperator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.ZeroOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns O(x)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.MatrixOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">MatrixOperator</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix wrapped into a LinearOperator</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>a numpy matrix</p>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.operators.MatrixOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> – numpy ndarray representing a matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.MatrixOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.MatrixOperator.calculate_norm">
<code class="sig-name descname">calculate_norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.calculate_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.calculate_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the norm of the LinearOperator as calculated by the PowerMethod</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default = 25</em>) – number of iterations to run</p></li>
<li><p><strong>x_init</strong> (same type as domain, a subclass of <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional, None) – starting point for the iteration in the operator domain</p></li>
<li><p><strong>force</strong> (boolean, default <code class="code docutils literal notranslate"><span class="pre">False</span></code>) – forces the recalculation of the norm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.MatrixOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.MaskOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">MaskOperator</code><span class="sig-paren">(</span><em class="sig-param">mask</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MaskOperator.html#MaskOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>MaskOperator:  D: X -&gt; X,  takes in a DataContainer or subclass 
thereof, mask, with True or 1.0 representing a value to be
kept and False or 0.0 a value to be lost/set to zero. Maps an element of 
<span class="math notranslate nohighlight">\(x\in X\)</span> onto the element <span class="math notranslate nohighlight">\(y \in X,  y = mask*x\)</span>, 
where * denotes elementwise multiplication.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param mask</dt>
<dd class="field-odd"><p>DataContainer of datatype bool or with 1/0 elements</p>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.operators.MaskOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">mask</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MaskOperator.html#MaskOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gradientoperator">
<h3>GradientOperator<a class="headerlink" href="#gradientoperator" title="Permalink to this headline">¶</a></h3>
<p>In the following the required classes for the implementation of the <code class="code docutils literal notranslate"><span class="pre">GradientOperator</span></code> operator.</p>
<dl class="class">
<dt id="cil.optimisation.operators.GradientOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">GradientOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">method='forward'</em>, <em class="sig-param">bnd_cond='Neumann'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Gradient Operator: Computes first-order forward/backward differences on </dt><dd><p>2D, 3D, 4D ImageData under Neumann/Periodic boundary conditions</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gm_domain</strong> (<cite>ImageGeometry</cite>) – Set up the domain of the function</p></li>
<li><p><strong>bnd_cond</strong> (<em>str</em><em>, </em><em>optional</em>) – Set the boundary conditions to use ‘Neumann’ or ‘Periodic’, defaults to ‘Neumann’</p></li>
<li><p><strong>**kwargs</strong> – See below</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>returns a BlockDataContainer containing images of the derivatives order given by <cite>dimension_labels</cite>i.e. [‘horizontal_y’,’horizontal_x’] will return [d(‘horizontal_y’), d(‘horizontal_x’)]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><em>correlation</em> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) –
‘Space’ or ‘SpaceChannels’, defaults to ‘Space’</p></li>
<li><p><em>backend</em> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) –
‘c’ or ‘numpy’, defaults to ‘c’ if correlation is ‘SpaceChannels’ or channels = 1</p></li>
<li><p><em>num_threads</em> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) –
If backend is ‘c’ specify the number of threads to use. Default is number of cpus/2</p></li>
<li><p><em>split</em> (<code class="docutils literal notranslate"><span class="pre">boolean</span></code>) –
If ‘True’, and backend ‘C’ will return a BlockDataContainer with grouped spatial domains. i.e. [Channel, [Z, Y, X]], otherwise [Channel, Z, Y, X]</p></li>
</ul>
<p>Example (2D): 
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">nabla</span> <span class="p">:</span> <span class="n">X</span> <span class="o">-&gt;</span> <span class="n">Y</span> \\
<span class="n">u</span>\<span class="ow">in</span> <span class="n">X</span><span class="p">,</span> \<span class="n">nabla</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span>\<span class="n">partial_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="n">u</span><span class="p">,</span> \<span class="n">partial_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="n">u</span><span class="p">]</span> \\
<span class="n">u</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="ow">in</span> <span class="n">Y</span><span class="p">,</span> \<span class="n">nabla</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}(</span><span class="n">u</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">})</span> <span class="o">=</span> \<span class="n">partial_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="n">v1</span> <span class="o">+</span> \<span class="n">partial_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="n">v2</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.operators.GradientOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">method='forward'</em>, <em class="sig-param">bnd_cond='Neumann'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor method</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.GradientOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the first-order backward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>BlockDataContainer</cite>) – Gradient images for each dimension in ImageGeometry domain</p></li>
<li><p><strong>out</strong> (<cite>ImageData</cite>, optional) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if not passed as parameter</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ImageData</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.GradientOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the first-order forward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>ImageData</cite>) – Image data</p></li>
<li><p><strong>out</strong> (<cite>BlockDataContainer</cite>, optional) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if not passed as parameter</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>BlockDataContainer</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">FiniteDifferenceOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em>, <em class="sig-param">direction=None</em>, <em class="sig-param">method='forward'</em>, <em class="sig-param">bnd_cond='Neumann'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes forward/backward/centered finite differences of a DataContainer 
under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – Domain geometry for the FiniteDifferenceOperator</p></li>
<li><p><strong>direction</strong> (<em>string label from domain geometry</em><em> or </em><em>integer number</em>) – Direction to evaluate finite differences</p></li>
<li><p><strong>method</strong> (<em>'forward'</em><em>, </em><em>'backward'</em><em>, </em><em>'centered'</em>) – Method for finite differences</p></li>
<li><p><strong>bnd_cond</strong> – ‘Neumann’, ‘Periodic’</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em>, <em class="sig-param">direction=None</em>, <em class="sig-param">method='forward'</em>, <em class="sig-param">bnd_cond='Neumann'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">SparseFiniteDifferenceOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">bnd_cond='Neumann'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Sparse Matrices for the Finite Difference Operator</p>
<dl class="method">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">range_geometry=None</em>, <em class="sig-param">direction=0</em>, <em class="sig-param">bnd_cond='Neumann'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">SymmetrisedGradientOperator</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">bnd_cond='Neumann'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetrized Gradient Operator:  E: V -&gt; W</p>
<p>V : range of the Gradient Operator
W : range of the Symmetrized Gradient</p>
<p>Example (2D):</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}v = (v1, v2) \\\end{split}\\\begin{split}Ev = 0.5 * ( \nabla\cdot v + (\nabla\cdot c)^{T} ) \\\end{split}\\\begin{split}\begin{matrix} 
    \partial_{y} v1 &amp; 0.5 * (\partial_{x} v1 + \partial_{y} v2) \\
    0.5 * (\partial_{x} v1 + \partial_{y} v2) &amp; \partial_{x} v2 
\end{matrix}\end{split}\end{aligned}\end{align} \]</div>
<dl class="method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">domain_geometry</em>, <em class="sig-param">bnd_cond='Neumann'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>bnd_cond</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code>) – boundary condition, either <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code> or <code class="code docutils literal notranslate"><span class="pre">Periodic</span></code>.</p></li>
<li><p><strong>correlation</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Channel</span></code>) – <code class="code docutils literal notranslate"><span class="pre">SpaceChannel</span></code> or <code class="code docutils literal notranslate"><span class="pre">Channel</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns E(v)</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="function">
<h2>Function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h2>
<p>A <code class="code docutils literal notranslate"><span class="pre">Function</span></code> represents a mathematical function of one or more inputs
and is intended to accept <code class="code docutils literal notranslate"><span class="pre">DataContainers</span></code> as input as well as any
additional parameters.</p>
<p>Fixed parameters can be passed in during the creation of the function object.
The methods of the function reflect the properties of it, for example, if the function
represented is differentiable the function should contain a method <code class="code docutils literal notranslate"><span class="pre">gradient</span></code>
which should return the gradient of the function evaluated at an input point.
If the function is not differentiable but allows a simple proximal operator,
the method <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> should return the proximal operator evaluated at an
input point. The function value is evaluated by calling the function itself,
e.g. <code class="code docutils literal notranslate"><span class="pre">f(x)</span></code> for a <code class="code docutils literal notranslate"><span class="pre">Function</span> <span class="pre">f</span></code> and input point <code class="code docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="section" id="base-classes">
<h3>Base classes<a class="headerlink" href="#base-classes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.Function">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">Function</code><span class="sig-paren">(</span><em class="sig-param">L=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class representing a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>number</em><em>, </em><em>positive</em><em>, </em><em>default None</em>) – Lipschitz constant of the gradient of the function F(x), when it is differentiable.</p></li>
<li><p><strong>domain</strong> – The domain of the function.</p></li>
</ul>
</dd>
</dl>
<p>Lipschitz of the gradient of the function; it is a positive real number, such that <a href="#id10"><span class="problematic" id="id11">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
<dl class="method">
<dt id="cil.optimisation.functions.Function.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.Function.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id12"><span class="problematic" id="id13">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.__add__">
<code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__add__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the functions.</p>
<dl class="simple">
<dt>Cases: a) the sum of two functions <span class="math notranslate nohighlight">\((F_{1}+F_{2})(x) = F_{1}(x) + F_{2}(x)\)</span></dt><dd><ol class="loweralpha simple" start="2">
<li><p>the sum of a function with a scalar <span class="math notranslate nohighlight">\((F_{1}+scalar)(x) = F_{1}(x) + scalar\)</span></p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">L=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.__radd__">
<code class="sig-name descname">__radd__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__radd__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>Making addition commutative.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.__rmul__">
<code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a function multiplied by a scalar.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.__sub__">
<code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subtraction of the functions.</p>
</dd></dl>

<dl class="attribute">
<dt id="cil.optimisation.functions.Function.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#cil.optimisation.functions.Function.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.centered_at">
<code class="sig-name descname">centered_at</code><span class="sig-paren">(</span><em class="sig-param">center</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.centered_at"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.centered_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.         
TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span> at x        
.. math:: mathrm{prox}_{tau F}(x) = underset{z}{mathrm{argmin}} frac{1}{2}|z - x|^{2} + tau F(z)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Function.proximal_conjugate">
<code class="sig-name descname">proximal_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.proximal_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\mathrm{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = x - \tau\mathrm{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.SumFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">SumFunction</code><span class="sig-paren">(</span><em class="sig-param">function1</em>, <em class="sig-param">function2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>SumFunction represents the sum of two functions</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2})(x)  = F_{1}(x) + F_{2}(x)\]</div>
<dl class="method">
<dt id="cil.optimisation.functions.SumFunction.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.SumFunction.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz constant</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SumFunction.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the sum of functions <span class="math notranslate nohighlight">\(F_{1}\)</span> and <span class="math notranslate nohighlight">\(F_{2}\)</span> at x</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2})(x) = F_{1}(x) + F_{2}(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SumFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">function1</em>, <em class="sig-param">function2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SumFunction.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions <span class="math notranslate nohighlight">\(F_{1}\)</span> and <span class="math notranslate nohighlight">\(F_{2}\)</span> at x, 
if both of them are differentiable</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2})(x)  = F'_{1}(x) + F'_{2}(x)\]</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.ScaledFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">ScaledFunction</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>ScaledFunction represents the scalar multiplication with a Function.</p>
<p>Let a function F then and a scalar <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = \alpha F(x)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = \alpha  F(x)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = \alpha  F'(x)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{(\tau\alpha) F}(x)\)</span> ( proximal method )</p></li>
</ol>
<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id14"><span class="problematic" id="id15">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G(x) = \alpha F(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the convex conjugate of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G'(x) = \alpha  F'(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of the scaled function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{(\tau\alpha) F}(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ScaledFunction.proximal_conjugate">
<code class="sig-name descname">proximal_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.proximal_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns the proximal operator for the function at x, tau</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.SumScalarFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">SumScalarFunction</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">constant</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>SumScalarFunction represents the sum a function with a scalar.</p>
<div class="math notranslate nohighlight">
\[(F + scalar)(x)  = F(x) + scalar\]</div>
<p>Although SumFunction has no general expressions for</p>
<ol class="lowerroman simple">
<li><p>convex_conjugate</p></li>
<li><p>proximal</p></li>
<li><p>proximal_conjugate</p></li>
</ol>
<p>if the second argument is a ConstantFunction then we can derive the above analytically.</p>
<dl class="method">
<dt id="cil.optimisation.functions.SumScalarFunction.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz constant</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SumScalarFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">constant</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SumScalarFunction.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the convex conjugate of a <span class="math notranslate nohighlight">\((F+scalar)\)</span></p>
<div class="math notranslate nohighlight">
\[(F+scalar)^{*}(x^{*}) = F^{*}(x^{*}) - scalar\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SumScalarFunction.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of <span class="math notranslate nohighlight">\(F+scalar\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{       au (F+scalar)}(x) = \mathrm{prox}_{     au F}\]</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.TranslateFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">TranslateFunction</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">center</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>TranslateFunction represents the translation of function F with respect to the center b.</p>
<p>Let a function F and consider <span class="math notranslate nohighlight">\(G(x) = F(x - center)\)</span>.</p>
<p>Function F is centered at 0, whereas G is centered at point b.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = F'(x - b)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{\tau F}(x - b)  + b\)</span> ( proximal method )</p></li>
</ol>
<dl class="method">
<dt id="cil.optimisation.functions.TranslateFunction.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the translated function.</p>
<div class="math notranslate nohighlight">
\[G(x) = F(x - b)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TranslateFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">center</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TranslateFunction.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the convex conjugate of the translated function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TranslateFunction.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the translated function.</p>
<div class="math notranslate nohighlight">
\[G'(x) =  F'(x - b)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TranslateFunction.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of the translated function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{\tau F}(x-b) + b\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-functions">
<h3>Simple functions<a class="headerlink" href="#simple-functions" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.ConstantFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">ConstantFunction</code><span class="sig-paren">(</span><em class="sig-param">constant=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>ConstantFunction: <span class="math notranslate nohighlight">\(F(x) = constant, constant\in\mathbb{R}\)</span></p>
<dl class="method">
<dt id="cil.optimisation.functions.ConstantFunction.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id16"><span class="problematic" id="id17">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ConstantFunction.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the function, <span class="math notranslate nohighlight">\(F(x) = constant\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ConstantFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">constant=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ConstantFunction.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*}) 
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ConstantFunction.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.ConstantFunction.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{       au F}(x) = x \]</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.ZeroFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">ZeroFunction</code><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ZeroFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>ZeroFunction represents the zero function, <span class="math notranslate nohighlight">\(F(x) = 0\)</span></p>
<dl class="method">
<dt id="cil.optimisation.functions.ZeroFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ZeroFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.Rosenbrock">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">Rosenbrock</code><span class="sig-paren">(</span><em class="sig-param">alpha</em>, <em class="sig-param">beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock" title="Permalink to this definition">¶</a></dt>
<dd><p>Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>F(x,y) = (alpha - x)^2 + beta(y-x^2)^2</p>
<p>The function has a global minimum at .. math:: (x,y)=(alpha, alpha^2)</p>
<dl class="method">
<dt id="cil.optimisation.functions.Rosenbrock.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Rosenbrock.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">alpha</em>, <em class="sig-param">beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.Rosenbrock.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of the Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>nabla f(x,y) = left[ 2*((x-alpha) - 2beta x(y-x^2)) ; 2beta (y - x^2)  right]</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="composition-of-operator-and-a-function">
<h3>Composition of operator and a function<a class="headerlink" href="#composition-of-operator-and-a-function" title="Permalink to this headline">¶</a></h3>
<p>This class allows the user to write a function which does the following:</p>
<div class="math notranslate nohighlight">
\[F ( x ) = G ( Ax )\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is an operator. For instance the least squares function <a href="#id28"><span class="problematic" id="id29">l2norm_</span></a> <code class="code docutils literal notranslate"><span class="pre">Norm2Sq</span></code> can
be expressed as</p>
<div class="math notranslate nohighlight">
\[F(x) = || Ax - b ||^2_2\]</div>
<dl class="class">
<dt id="cil.optimisation.functions.OperatorCompositionFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">OperatorCompositionFunction</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">operator</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Composition of a function with an operator as : <span class="math notranslate nohighlight">\((F \otimes A)(x) = F(Ax)\)</span></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">parameter function</dt>
<dd class="field-odd"><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code> F</p>
</dd>
<dt class="field-even">parameter operator</dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code> A</p>
</dd>
</dl>
</div></blockquote>
<p>For general operator, we have no explicit formulas for convex_conjugate,
proximal and proximal_conjugate</p>
<dl class="method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id18"><span class="problematic" id="id19">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(F(Ax)\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">operator</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<code class="code docutils literal notranslate"><span class="pre">Operator</span></code>) – operator</p></li>
<li><p><strong>f</strong> (<code class="code docutils literal notranslate"><span class="pre">Function</span></code>) – function</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gradient of F(Ax),</p>
<p>..math ::  (F(Ax))’ = A^{T}F’(Ax)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indicator-box">
<h3>Indicator box<a class="headerlink" href="#indicator-box" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.IndicatorBox">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">IndicatorBox</code><span class="sig-paren">(</span><em class="sig-param">lower=-inf</em>, <em class="sig-param">upper=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator function for box constraint</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(x) = \mathbb{I}_{[a, b]} = \begin{cases}  
                                   0, \text{ if } x \in [a, b] \\
                                   \infty, \text{otherwise}
                            \end{cases}\end{split}\]</div>
<dl class="method">
<dt id="cil.optimisation.functions.IndicatorBox.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates IndicatorBox at x</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.IndicatorBox.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">lower=-inf</em>, <em class="sig-param">upper=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower</strong> (float, default = <code class="code docutils literal notranslate"><span class="pre">-numpy.inf</span></code>) – lower bound</p></li>
<li><p><strong>upper</strong> (float, optional, default = <code class="code docutils literal notranslate"><span class="pre">numpy.inf</span></code>) – upper bound</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.IndicatorBox.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Convex conjugate of IndicatorBox at x</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.IndicatorBox.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.IndicatorBox.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal operator of IndicatorBox at x</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f}(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.IndicatorBox.proximal_conjugate">
<code class="sig-name descname">proximal_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.proximal_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal operator of the convex conjugate of IndicatorBox at x:</p>
<p>..math:: prox_{tau * f^{*}}(x)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="kullbackleibler">
<h3>KullbackLeibler<a class="headerlink" href="#kullbackleibler" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.KullbackLeibler">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">KullbackLeibler</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler" title="Permalink to this definition">¶</a></dt>
<dd><p>Kullback Leibler divergence function is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(u, v)
= \begin{cases} 
u \log(\frac{u}{v}) - u + v &amp; \mbox{ if } u &gt; 0, v &gt; 0\\
v &amp; \mbox{ if } u = 0, v \ge 0 \\
\infty, &amp; \mbox{otherwise}
\end{cases}  \end{split}\]</div>
<p>where we use the <span class="math notranslate nohighlight">\(0\log0 := 0\)</span> convention.</p>
<p>At the moment, we use build-in implemention of scipy, see
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html</a></p>
<p>The Kullback-Leibler function is used as a fidelity term in minimisation problems where the
acquired data follow Poisson distribution. If we denote the acquired data with <span class="math notranslate nohighlight">\(b\)</span>
then, we write</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\underset{i}{\sum} F(b_{i}, (v + \eta)_{i})\]</div>
<p>where, <span class="math notranslate nohighlight">\(\eta\)</span> is an additional noise.</p>
<p>Example: In the case of Positron Emission Tomography reconstruction <span class="math notranslate nohighlight">\(\eta\)</span> represents 
scatter and random events contribution during the PET acquisition. Hence, in that case the KullbackLeibler
fidelity measures the distance between <span class="math notranslate nohighlight">\(\mathcal{A}v + \eta\)</span> and acquisition data <span class="math notranslate nohighlight">\(b\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the projection operator.</p>
<p>This is related to PoissonLogLikelihoodWithLinearModelForMean definition that is used in PET reconstruction
in the PET-MR software , see <a class="reference external" href="https://github.com/CCPPETMR">https://github.com/CCPPETMR</a> and for more details in</p>
</div></blockquote>
<p><a class="reference external" href="http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html">http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html</a></p>
<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.
To avoid infinity values, we consider only pixels/voxels for <span class="math notranslate nohighlight">\(x+\eta\geq0\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the convex conjugate of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(b, x + \eta) = - b \log(1-x^{*}) - &lt;x^{*}, \eta&gt; \]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[F'(b, x + \eta) = 1 - \frac{b}{x+\eta}\]</div>
<p>We require the <span class="math notranslate nohighlight">\(x+\eta&gt;0\)</span> otherwise we have inf values.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">datacontainer</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.log" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the in-place log of the datacontainer</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the proximal operator of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{1}{2}\bigg( (x - \eta - \tau) + \sqrt{ (x + \eta - \tau)^2 + 4\tau b} \bigg)\]</div>
<p>The proximal for the convex conjugate of <span class="math notranslate nohighlight">\(F\)</span> is</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = 0.5*((z + 1) - \sqrt{(z-1)^2 + 4 * \tau b})\]</div>
<p>where <span class="math notranslate nohighlight">\(z = x + \tau \eta\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.KullbackLeibler.proximal_conjugate">
<code class="sig-name descname">proximal_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.proximal_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal operator of the convex conjugate of KullbackLeibler at x:</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f^{*}}(x)\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="l1-norm">
<h3>L1 Norm<a class="headerlink" href="#l1-norm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.L1Norm">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">L1Norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm" title="Permalink to this definition">¶</a></dt>
<dd><p>L1Norm function</p>
<dl>
<dt>Consider the following cases:           </dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.functions.L1Norm.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the L1Norm function at x.</p>
<dl>
<dt>Consider the following cases:           </dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}        \]</div>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L1Norm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<p>Cases considered (with/without data):            
a) <span class="math notranslate nohighlight">\(f(x) = ||x||_{1}\)</span>
b) <span class="math notranslate nohighlight">\(f(x) = ||x - b||_{1}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional) – translation of the function</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L1Norm.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the convex conjugate of the L1Norm function at x.
Here, we need to use the convex conjugate of L1Norm, which is the Indicator of the unit 
<span class="math notranslate nohighlight">\(L^{\infty}\)</span> norm</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) \]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) + &lt;x^{*},b&gt;      \]</div>
</li>
</ol>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) 
= \begin{cases} 
0, \mbox{if } \|x^{*}\|_{\infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L1Norm.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the proximal operator of the L1Norm function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) + b   \]</div>
</li>
</ol>
</div></blockquote>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) = sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="squared-l2-norm-squared">
<h3>Squared L2 norm squared<a class="headerlink" href="#squared-l2-norm-squared" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.L2NormSquared">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">L2NormSquared</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared" title="Permalink to this definition">¶</a></dt>
<dd><p>L2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|^{2}_{2} = \underset{i}{\sum}x_{i}^{2}\)</span></p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For case b) case we can use <code class="code docutils literal notranslate"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">L2NormSquared().centered_at(b)</span></code>,
see <em>TranslateFunction</em>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span><span class="o">.</span><span class="n">centered_at</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="cil.optimisation.functions.L2NormSquared.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(x\)</span></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\underset{i}{\sum}x_{i}^{2}\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L2NormSquared.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creator</p>
<dl>
<dt>Cases considered (with/without data):            </dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[f(x) = \|x\|^{2}_{2} \]</div>
</li>
<li><div class="math notranslate nohighlight">
\[f(x) = \|\|x - b\|\|^{2}_{2}\]</div>
</li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional) – translation of the function</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L2NormSquared.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the convex conjugate of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2} \]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2} + &lt;x^{*}, b&gt;\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L2NormSquared.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2(x-b)\)</span></p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.L2NormSquared.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the proximal operator of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{1+2\tau}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x-b}{1+2\tau} + b      \]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cil.optimisation.functions.WeightedL2NormSquared">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">WeightedL2NormSquared</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared" title="Permalink to this definition">¶</a></dt>
<dd><p>WeightedL2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|_{w}^{2}_{2} = \underset{i}{\sum}w_{i}*x_{i}^{2} = &lt;x, w*x&gt; = x^{T}*w*x\)</span></p>
<dl class="method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span> at x        
.. math:: mathrm{prox}_{tau F}(x) = underset{z}{mathrm{argmin}} frac{1}{2}|z - x|^{2} + tau F(z)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="least-squares">
<h3>Least Squares<a class="headerlink" href="#least-squares" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.LeastSquares">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">LeastSquares</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">b</em>, <em class="sig-param">c=1.0</em>, <em class="sig-param">weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>(Weighted) Least Squares function</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_2^2 \]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_{2,W}^{2}\]</div>
<p>Parameters:</p>
<blockquote>
<div><p>A : Operator</p>
<p>c : Scaling Constant</p>
<p>b : Data</p>
<p>weight: 1.0 (Default) or DataContainer</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>L : Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||A||_2^2 = 2 c s1(A)^2\)</span>, or</p>
<p>L : Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||weight|| ||A||_2^2 = 2s1(A)^2\)</span>,</p>
</div></blockquote>
<p>where s1(A) is the largest singular value of A.</p>
<dl class="method">
<dt id="cil.optimisation.functions.LeastSquares.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id20"><span class="problematic" id="id21">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.LeastSquares.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of <span class="math notranslate nohighlight">\(F(x) = c\|Ax-b\|_2^2\)</span> or c|Ax-b|_{2,weight}^2</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.LeastSquares.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">b</em>, <em class="sig-param">c=1.0</em>, <em class="sig-param">weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.LeastSquares.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of <span class="math notranslate nohighlight">\(F(x) = c*\|A*x-b\|_2^2\)</span></p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(Ax-b)\]</div>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(weight(Ax-b))\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mixed-l21-norm">
<h3>Mixed L21 norm<a class="headerlink" href="#mixed-l21-norm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.MixedL21Norm">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">MixedL21Norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm" title="Permalink to this definition">¶</a></dt>
<dd><p>MixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<dl class="method">
<dt id="cil.optimisation.functions.MixedL21Norm.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the MixedL21Norm function at x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.MixedL21Norm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.MixedL21Norm.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the convex conjugate of the MixedL21Norm function at x.</p>
<p>This is the Indicator function of <span class="math notranslate nohighlight">\(\mathbb{I}_{\{\|\cdot\|_{2,\infty}\leq1\}}(x^{*})\)</span>,</p>
<p>i.e.,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{2, \infty}\leq1\}}(x^{*}) 
= \begin{cases} 
0, \mbox{if } \|x\|_{2, \infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\|x\|_{2,\infty} = \max\{ \|x\|_{2} \} = \max\{ \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\}\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.MixedL21Norm.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL21Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{\|x\|_{2}}\max\{ \|x\|_{2} - \tau, 0 \}\]</div>
<p>where the convention 0 · (0/0) = 0 is used.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="smooth-mixed-l21-norm">
<h3>Smooth Mixed L21 norm<a class="headerlink" href="#smooth-mixed-l21-norm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">SmoothMixedL21Norm</code><span class="sig-paren">(</span><em class="sig-param">epsilon</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm" title="Permalink to this definition">¶</a></dt>
<dd><p>SmoothMixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \epsilon^2 + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<p>Conjugate, proximal and proximal conjugate methods no closed-form solution</p>
<dl class="method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the SmoothMixedL21Norm function at x.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">epsilon</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epsilon</strong> – smoothing parameter making MixedL21Norm differentiable</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of the SmoothMixedL21Norm function at x.</p>
<p>frac{x}{<a href="#id22"><span class="problematic" id="id23">|x|</span></a>}</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="total-variation">
<h3>Total variation<a class="headerlink" href="#total-variation" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="cil.optimisation.functions.TotalVariation">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">TotalVariation</code><span class="sig-paren">(</span><em class="sig-param">max_iteration=100</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">correlation='Space'</em>, <em class="sig-param">backend='c'</em>, <em class="sig-param">lower=-inf</em>, <em class="sig-param">upper=inf</em>, <em class="sig-param">info=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast Gradient Projection algorithm for Total Variation(TV) Denoising (ROF problem)</p>
<div class="math notranslate nohighlight">
\[\min_{x} \alpha TV(x) + \frac{1}{2}||x-b||^{2}_{2}\]</div>
<p>Parameters:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param max_iteration</dt>
<dd class="field-odd"><p>max iterations of FGP algorithm</p>
</dd>
<dt class="field-even">type max_iteration</dt>
<dd class="field-even"><p>int, default 100</p>
</dd>
<dt class="field-odd">param tolerance</dt>
<dd class="field-odd"><p>Stopping criterion</p>
</dd>
<dt class="field-even">type tolerance</dt>
<dd class="field-even"><p>float, default <cite>None</cite></p>
</dd>
<dt class="field-odd">param correlation</dt>
<dd class="field-odd"><p>Correlation between <cite>Space</cite> and/or <cite>SpaceChannels</cite> for the GradientOperator</p>
</dd>
<dt class="field-even">type correlation</dt>
<dd class="field-even"><p>str, default ‘Space’</p>
</dd>
<dt class="field-odd">param backend</dt>
<dd class="field-odd"><p>Backend to compute finite differences for the GradientOperator</p>
</dd>
<dt class="field-even">type backend</dt>
<dd class="field-even"><p>str, default ‘c’</p>
</dd>
</dl>
<p>:param lower:lower bound for the orthogonal projection onto the convex set C
:type lower: Number, default <cite>-numpy.inf</cite>
:param upper: upper bound for the orthogonal projection onto the convex set C
:type upper: Number, default <cite>+numpy.inf</cite>
:param info: force a print to screen stating the stop
:type info: bool, default <cite>False</cite></p>
</div></blockquote>
<p>Reference:</p>
<blockquote>
<div><p>A. Beck and M. Teboulle, “Fast Gradient-Based Algorithms for Constrained Total Variation 
Image Denoising and Deblurring Problems,” in IEEE Transactions on Image Processing,
vol. 18, no. 11, pp. 2419-2434, Nov. 2009, 
doi: 10.1109/TIP.2009.2028250.</p>
</div></blockquote>
<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id24"><span class="problematic" id="id25">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the alpha * TV(x)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">max_iteration=100</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">correlation='Space'</em>, <em class="sig-param">backend='c'</em>, <em class="sig-param">lower=-inf</em>, <em class="sig-param">upper=inf</em>, <em class="sig-param">info=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.__rmul__">
<code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a function multiplied by a scalar.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.gradient">
<em class="property">property </em><code class="sig-name descname">gradient</code><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a gradient operator if not instantiated yet</p>
<p>There is no check that the variable _domain is changed after instantiation (should not be the case)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.projection_C">
<code class="sig-name descname">projection_C</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.projection_C"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.projection_C" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns orthogonal projection onto the convex set C</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.projection_P">
<code class="sig-name descname">projection_P</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.projection_P"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.projection_P" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the projection P onto |cdot|_{infty}</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.TotalVariation.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution of the FGP_TV algorithm</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="block-framework">
<h1>Block Framework<a class="headerlink" href="#block-framework" title="Permalink to this headline">¶</a></h1>
<p>To be able to express more advanced optimisation problems we developed the
<a class="reference internal" href="#block-framework">Block Framework</a>, which provides a generic strategy to treat variational
problems in the following form:</p>
<div class="math notranslate nohighlight">
\[\min \text{Regulariser} + \text{Fidelity}\]</div>
<p>The block framework consists of:</p>
<ul class="simple">
<li><p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a></p></li>
</ul>
<div class="section" id="blockdatacontainer">
<h2>BlockDataContainer<a class="headerlink" href="#blockdatacontainer" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> holds <a href="#id30"><span class="problematic" id="id31">`DataContainer`_</span></a> as column vector. It is possible to
do basic algebra between <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> s and with numbers, list or numpy arrays.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = [x_{1}, x_{2} ]\in (X_{1}\times X_{2})\\y = [y_{1}, y_{2}, y_{3} ]\in(Y_{1}\times Y_{2} \times Y_{3})\end{aligned}\end{align} \]</div>
<dl class="class">
<dt id="cil.framework.BlockDataContainer">
<em class="property">class </em><code class="sig-prename descclassname">cil.framework.</code><code class="sig-name descname">BlockDataContainer</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to hold DataContainers as column vector</p>
<p>Provides basic algebra between BlockDataContainer’s, DataContainer’s and
subclasses and Numbers</p>
<ol class="arabic simple">
<li><p>algebra between <a href="#id5"><span class="problematic" id="id6">`</span></a>BlockDataContainer`s will be element-wise, only if 
the shape of the 2 <a href="#id7"><span class="problematic" id="id8">`</span></a>BlockDataContainer`s is the same, otherwise it 
will fail</p></li>
<li><p>algebra between <cite>BlockDataContainer`s and `list</cite> or <cite>numpy array</cite> will 
work as long as the number of <cite>rows</cite> and element of the arrays match,
indipendently on the fact that the <cite>BlockDataContainer</cite> could be nested</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and one <cite>DataContainer</cite> is possible.
It will require that all the <cite>DataContainers</cite> in the block to be
compatible with the <cite>DataContainer</cite> we want to algebra with. Should we 
require that the <cite>DataContainer</cite> is the same type? Like <cite>ImageData</cite> or <cite>AcquisitionData</cite>?</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and a <cite>Number</cite> is possible and it
will be done with each element of the <cite>BlockDataContainer</cite> even if nested</p></li>
</ol>
<p>A = [ [B,C] , D] 
A * 3 = [ 3 * [B,C] , 3* D] = [ [ 3*B, 3*C]  , 3*D ]</p>
<dl class="method">
<dt id="cil.framework.BlockDataContainer.__iadd__">
<code class="sig-name descname">__iadd__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__iadd__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline addition</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__idiv__">
<code class="sig-name descname">__idiv__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__idiv__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__idiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline division</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__imul__">
<code class="sig-name descname">__imul__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__imul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__imul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline multiplication</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__isub__">
<code class="sig-name descname">__isub__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__isub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__isub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline subtraction</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>BlockDataContainer is Iterable</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__itruediv__">
<code class="sig-name descname">__itruediv__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__itruediv__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__itruediv__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline truedivision</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__neg__">
<code class="sig-name descname">__neg__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__neg__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return - self</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__radd__">
<code class="sig-name descname">__radd__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__radd__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse addition</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__rdiv__">
<code class="sig-name descname">__rdiv__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rdiv__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse division</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__rmul__">
<code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse multiplication</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__rpow__">
<code class="sig-name descname">__rpow__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rpow__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rpow__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse power</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__rsub__">
<code class="sig-name descname">__rsub__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rsub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse subtraction</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.__rtruediv__">
<code class="sig-name descname">__rtruediv__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rtruediv__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rtruediv__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse truedivision</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="attribute">
<dt id="cil.framework.BlockDataContainer.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#cil.framework.BlockDataContainer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: add method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.axpby">
<code class="sig-name descname">axpby</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">y</em>, <em class="sig-param">out</em>, <em class="sig-param">dtype=&lt;class 'numpy.float32'&gt;</em>, <em class="sig-param">num_threads=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.axpby"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.axpby" title="Permalink to this definition">¶</a></dt>
<dd><p>performs axpby element-wise on the BlockDataContainer containers</p>
<p>Does the operation .. math:: a*x+b*y and stores the result in out, where x is self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – scalar</p></li>
<li><p><strong>b</strong> – scalar</p></li>
<li><p><strong>y</strong> – compatible (Block)DataContainer</p></li>
<li><p><strong>out</strong> – (Block)DataContainer to store the result</p></li>
<li><p><strong>dtype</strong> – optional, data type of the DataContainers</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.binary_operations">
<code class="sig-name descname">binary_operations</code><span class="sig-paren">(</span><em class="sig-param">operation</em>, <em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.binary_operations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.binary_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: generic method of algebric operation with BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<p>Provides commutativity with DataContainer and subclasses, i.e. this 
class’s reverse algebric methods take precedence w.r.t. direct algebric
methods of DataContainer and subclasses.</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of clone</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.divide">
<code class="sig-name descname">divide</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: divide method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.is_compatible">
<code class="sig-name descname">is_compatible</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.is_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>basic check if the size of the 2 objects fit</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.maximum">
<code class="sig-name descname">maximum</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.maximum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.minimum">
<code class="sig-name descname">minimum</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.minimum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.multiply">
<code class="sig-name descname">multiply</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: multiply method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.next">
<code class="sig-name descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.next" title="Permalink to this definition">¶</a></dt>
<dd><p>python2 backwards compatibility</p>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.power">
<code class="sig-name descname">power</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.subtract">
<code class="sig-name descname">subtract</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.subtract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebra: subtract method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.framework.BlockDataContainer.unary_operations">
<code class="sig-name descname">unary_operations</code><span class="sig-paren">(</span><em class="sig-param">operation</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.unary_operations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.unary_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary operation on BlockDataContainer:</p>
<p>generic method of unary operation with BlockDataContainer: abs, sign, sqrt and conjugate</p>
<p>This method is not to be used directly</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="block-function">
<h2>Block Function<a class="headerlink" href="#block-function" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> acts on <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> as a separable sum function:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}f = [f_1,...,f_n] \newline\\f([x_1,...,x_n]) = f_1(x_1) +  .... + f_n(x_n)\end{aligned}\end{align} \]</div>
</div></blockquote>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}Y = \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}\\
\end{bmatrix}, \quad  F  = [ f_{1}, f_{2}, f_{3} ]\end{split}\\F(Y) : = f_{1}(y_{1}) + f_{2}(y_{2}) + f_{3}(y_{3})\end{aligned}\end{align} \]</div>
<dl class="class">
<dt id="cil.optimisation.functions.BlockFunction">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.functions.</code><code class="sig-name descname">BlockFunction</code><span class="sig-paren">(</span><em class="sig-param">*functions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>BlockFunction represents a <em>separable sum</em> function <span class="math notranslate nohighlight">\(F\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[F:X_{1}\times X_{2}\cdots\times X_{m} \rightarrow (-\infty, \infty]\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is the separable sum of functions <span class="math notranslate nohighlight">\((f_{i})_{i=1}^{m}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F(x_{1}, x_{2}, \cdots, x_{m}) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ with } f_{i}: X_{i} \rightarrow (-\infty, \infty].\]</div>
<p>A nice property (due to it’s separability structure) is that the proximal operator 
can be decomposed along the proximal operators of each function <span class="math notranslate nohighlight">\(f_{i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<p>In addition, if <span class="math notranslate nohighlight">\(\tau := (\tau_{1},\dots,\tau_{m})\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau_{i} f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.L">
<em class="property">property </em><code class="sig-name descname">L</code><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id26"><span class="problematic" id="id27">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the BlockFunction <span class="math notranslate nohighlight">\(F\)</span></p>
<div class="math notranslate nohighlight">
\[F(x) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ where } x = (x_{1}, x_{2}, \cdots, x_{m}), \quad i = 1,2,\dots,m\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
<p>returns ..math:: sum(f_i(x_i))</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*functions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.convex_conjugate">
<code class="sig-name descname">convex_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.convex_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.convex_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the convex conjugate of the BlockFunction at <span class="math notranslate nohighlight">\(x^{*}\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \overset{m}{\underset{i=1}{\sum}}f_{i}^{*}(x^{*}_{i})\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gradient of the BlockFunction function at x.</p>
<div class="math notranslate nohighlight">
\[F'(x) = [f_{1}'(x_{1}), ... , f_{m}'(x_{m})]        \]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.proximal">
<code class="sig-name descname">proximal</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.proximal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal operator of the BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) =  (\mathrm{prox}_{\tau f_{i}}(x_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.functions.BlockFunction.proximal_conjugate">
<code class="sig-name descname">proximal_conjugate</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">tau</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.proximal_conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal_conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Proximal operator of the convex conjugate of BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = (\mathrm{prox}_{\tau f^{*}_{i}}(x^{*}_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="block-operator">
<h2>Block Operator<a class="headerlink" href="#block-operator" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a> represent a block matrix with operators</p>
<div class="math notranslate nohighlight">
\[\begin{split}K = \begin{bmatrix}
     A_{1} &amp; A_{2} \\
     A_{3} &amp; A_{4} \\
     A_{5} &amp; A_{6}
\end{bmatrix}_{(3,2)} *  \quad \underbrace{\begin{bmatrix}
x_{1} \\
x_{2}
\end{bmatrix}_{(2,1)}}_{\textbf{x}} =  \begin{bmatrix}
A_{1}x_{1}  + A_{2}x_{2}\\
A_{3}x_{1}  + A_{4}x_{2}\\
A_{5}x_{1}  + A_{6}x_{2}\\
\end{bmatrix}_{(3,1)} =  \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}
\end{bmatrix}_{(3,1)} = \textbf{y}\end{split}\]</div>
<p>Column: Share the same domains <span class="math notranslate nohighlight">\(X_{1}, X_{2}\)</span></p>
<p>Rows: Share the same ranges <span class="math notranslate nohighlight">\(Y_{1}, Y_{2}, Y_{3}\)</span></p>
<div class="math notranslate nohighlight">
\[K : (X_{1}\times X_{2}) \rightarrow (Y_{1}\times Y_{2} \times Y_{3})\]</div>
<p><span class="math notranslate nohighlight">\(A_{1}, A_{3}, A_{5}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{1}\)</span> and
<span class="math notranslate nohighlight">\(A_{2}, A_{4}, A_{6}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{2}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{1}: X_{1} \rightarrow Y_{1} \\
A_{3}: X_{1} \rightarrow Y_{2} \\
A_{5}: X_{1} \rightarrow Y_{3} \\
A_{2}: X_{2} \rightarrow Y_{1} \\
A_{4}: X_{2} \rightarrow Y_{2} \\
A_{6}: X_{2} \rightarrow Y_{3}\end{split}\]</div>
<p>For instance with these ingredients one may write the following objective
function,</p>
<div class="math notranslate nohighlight">
\[\alpha ||\nabla u||_{2,1} + ||u - g||_2^2\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> represent the measured values, <span class="math notranslate nohighlight">\(u\)</span> the solution
<span class="math notranslate nohighlight">\(\nabla\)</span> is the gradient operator, <span class="math notranslate nohighlight">\(|| ~~ ||_{2,1}\)</span> is a norm for
the output of the gradient operator and <span class="math notranslate nohighlight">\(|| x-g ||^2_2\)</span> is
least squares fidelity function as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}K = \begin{bmatrix}
          \nabla \\
          \mathbb{1}
        \end{bmatrix}\end{split}\\F(x) = \Big[ \alpha \lVert ~x~ \rVert_{2,1} ~~ , ~~ || x - g||_2^2 \Big]\\w = [ u ]\end{aligned}\end{align} \]</div>
<p>Then we have rewritten the problem as</p>
<div class="math notranslate nohighlight">
\[F(Kw) =   \alpha \left\lVert \nabla u \right\rVert_{2,1} + ||u-g||^2_2\]</div>
<p>Which in Python would be like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">GradientOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="n">GradientOperator</span><span class="o">.</span><span class="n">CORRELATION_SPACE</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

<span class="c1"># Create BlockOperator</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">BlockOperator</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>

<span class="c1"># Create functions</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">BlockFunction</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">MixedL21Norm</span><span class="p">(),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">noisy_data</span><span class="p">))</span>
</pre></div>
</div>
<dl class="class">
<dt id="cil.optimisation.operators.BlockOperator">
<em class="property">class </em><code class="sig-prename descclassname">cil.optimisation.operators.</code><code class="sig-name descname">BlockOperator</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>A Block matrix containing Operators</p>
<p>The Block Framework is a generic strategy to treat variational problems in the
following form:</p>
<div class="math notranslate nohighlight">
\[\min Regulariser + Fidelity\]</div>
<p>BlockOperators have a generic shape M x N, and when applied on an 
Nx1 BlockDataContainer, will yield and Mx1 BlockDataContainer.
Notice: BlockDatacontainer are only allowed to have the shape of N x 1, with
N rows and 1 column.</p>
<p>User may specify the shape of the block, by default is a row vector</p>
<p>Operators in a Block are required to have the same domain column-wise and the
same range row-wise.</p>
<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.T">
<em class="property">property </em><code class="sig-name descname">T</code><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transposed of self</p>
<p>input in a row-by-row</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the index-th operator in the block irrespectively of it’s shape</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Class creator</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Do not include the <cite>self</cite> parameter in the <code class="docutils literal notranslate"><span class="pre">Args</span></code> section.</p>
</dd>
<dt>Args:</dt><dd><dl class="field-list simple">
<dt class="field-odd">param</dt>
<dd class="field-odd"><p>vararg (Operator): Operators in the block.</p>
</dd>
<dt class="field-even">param</dt>
<dd class="field-even"><p>shape (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>, optional): If shape is passed the Operators in 
vararg are considered input in a row-by-row fashion. 
Shape and number of Operators must match.</p>
</dd>
</dl>
</dd>
<dt>Example:</dt><dd><p>BlockOperator(op0,op1) results in a row block
BlockOperator(op0,op1,shape=(1,2)) results in a column block</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.__rmul__">
<code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">scalar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the left multiplication with a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Paramer scalar</dt>
<dd class="field-odd"><p>(number or iterable containing numbers):</p>
</dd>
</dl>
<p>Returns: a block operator with Scaled Operators inside</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.adjoint">
<code class="sig-name descname">adjoint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.adjoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint operation for the BlockOperator</p>
<p>BlockOperator may contain both LinearOperator and Operator
This method exists in BlockOperator as it is not known what type of
Operator it will contain.</p>
<p>BlockOperator work on BlockDataContainer, but they will work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
<p>Raises: ValueError if the contained Operators are not linear</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.column_wise_compatible">
<code class="sig-name descname">column_wise_compatible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.column_wise_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.column_wise_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators in a Block should have the same domain per column</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.direct">
<code class="sig-name descname">direct</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct operation for the BlockOperator</p>
<p>BlockOperator work on BlockDataContainer, but they will work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.domain_geometry">
<code class="sig-name descname">domain_geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.domain_geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.domain_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the BlockOperator</p>
<p>If the shape of the BlockOperator is (N,1) the domain is a ImageGeometry or AcquisitionGeometry.
Otherwise it is a BlockGeometry.</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.get_item">
<code class="sig-name descname">get_item</code><span class="sig-paren">(</span><em class="sig-param">row</em>, <em class="sig-param">col</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_item"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_item" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the Operator at specified row and col</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.get_output_shape">
<code class="sig-name descname">get_output_shape</code><span class="sig-paren">(</span><em class="sig-param">xshape</em>, <em class="sig-param">adjoint=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_output_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_output_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the shape of the output BlockDataContainer</p>
<p>A(N,M) direct u(M,1) -&gt; N,1
A(N,M)^T adjoint u(N,1) -&gt; M,1</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.is_linear">
<code class="sig-name descname">is_linear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.is_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.is_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>returns whether all the elements of the BlockOperator are linear</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the norm of the BlockOperator</p>
<p>if the operator in the block do not have method norm defined, i.e. they are SIRF
AcquisitionModel’s we use PowerMethod if applicable, otherwise we raise an Error</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.range_geometry">
<code class="sig-name descname">range_geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.range_geometry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.range_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the range of the BlockOperator</p>
</dd></dl>

<dl class="method">
<dt id="cil.optimisation.operators.BlockOperator.row_wise_compatible">
<code class="sig-name descname">row_wise_compatible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.row_wise_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.row_wise_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators in a Block should have the same range per row</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="index.html#mastertoc"><span class="std std-ref">Return Home</span></a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="developer_guide.html" class="btn btn-neutral float-right" title="Developer’s guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="io.html" class="btn btn-neutral float-left" title="Read/ write AcquisitionData and ImageData" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2017-2021 UKRI-STFC, University of Manchester.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>